(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{240:function(t,r,a){"use strict";a.r(r);var e=a(12),_=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("专栏原创出处："),a("a",{attrs:{href:"https://github.com/GourdErwa/review-notes",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源笔记文件 "),a("OutboundLink")],1),t._v(" ，"),a("a",{attrs:{href:"https://github.com/GourdErwa/leetcode",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源码 "),a("OutboundLink")],1),t._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#_1-特点"}},[t._v("1. 特点")])]),a("li",[a("a",{attrs:{href:"#状态的定义"}},[t._v("状态的定义")])]),a("li",[a("a",{attrs:{href:"#_2-动态规划解题思路"}},[t._v("2.动态规划解题思路")]),a("ul",[a("li",[a("a",{attrs:{href:"#确定状态"}},[t._v("确定状态")])]),a("li",[a("a",{attrs:{href:"#转移方程"}},[t._v("转移方程")])]),a("li",[a("a",{attrs:{href:"#初始条件和边界情况"}},[t._v("初始条件和边界情况")])]),a("li",[a("a",{attrs:{href:"#计算顺序"}},[t._v("计算顺序")])]),a("li",[a("a",{attrs:{href:"#动态规划解题思路总结"}},[t._v("动态规划解题思路总结")])])])]),a("li",[a("a",{attrs:{href:"#常见动态规划类型"}},[t._v("常见动态规划类型")])]),a("li",[a("a",{attrs:{href:"#参考"}},[t._v("参考")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"_1-特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-特点"}},[t._v("#")]),t._v(" 1. 特点")]),t._v(" "),a("p",[t._v("分值算法：将原问题划分为互不相交的子问题，递归地求解子问题，然后再将他们的解组合起来。")]),t._v(" "),a("p",[t._v("动态规划：子问题重叠的情况，不同的子问题具有公共的子子问题。")]),t._v(" "),a("p",[t._v("最优子结构：问题的最优解由相关子问题的最优解组合而成。")]),t._v(" "),a("p",[t._v("边界：问题的边界，得到有限的结果。")]),t._v(" "),a("p",[t._v("动态转移方程：问题每一阶段和下一阶段的关系")]),t._v(" "),a("h2",{attrs:{id:"状态的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态的定义"}},[t._v("#")]),t._v(" 状态的定义")]),t._v(" "),a("ol",[a("li",[t._v("问题中的状态满足最优性原理。-》最优子结构")]),t._v(" "),a("li",[t._v("问题中的状态必须满足无后效性。-》以前出现的状态以及以前状态的变化不会影响将来的变化。")]),t._v(" "),a("li",[t._v("计数\n"),a("ul",[a("li",[t._v("有多少种方式走到右下角")]),t._v(" "),a("li",[t._v("有多少种方法选出 k 个数使得和是 Sum")])])]),t._v(" "),a("li",[t._v("最值\n"),a("ul",[a("li",[t._v("从左上角走到右下角路径的最大数字和")]),t._v(" "),a("li",[t._v("最长升子序列长度")])])]),t._v(" "),a("li",[t._v("存在性\n"),a("ul",[a("li",[t._v("取石子游戏，先手是否必胜")]),t._v(" "),a("li",[t._v("能不能选出k个数使得和是Sum")])])])]),t._v(" "),a("h2",{attrs:{id:"_2-动态规划解题思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态规划解题思路"}},[t._v("#")]),t._v(" 2.动态规划解题思路")]),t._v(" "),a("h3",{attrs:{id:"确定状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#确定状态"}},[t._v("#")]),t._v(" 确定状态")]),t._v(" "),a("ul",[a("li",[t._v("确定最优策略的最后一步")]),t._v(" "),a("li",[t._v("转换为子问题")])]),t._v(" "),a("h3",{attrs:{id:"转移方程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转移方程"}},[t._v("#")]),t._v(" 转移方程")]),t._v(" "),a("p",[t._v("根据子问题的定义写出递归方程")]),t._v(" "),a("h3",{attrs:{id:"初始条件和边界情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始条件和边界情况"}},[t._v("#")]),t._v(" 初始条件和边界情况")]),t._v(" "),a("h3",{attrs:{id:"计算顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算顺序"}},[t._v("#")]),t._v(" 计算顺序")]),t._v(" "),a("p",[t._v("需要看转移方程等式左边的变量与等式右边变量的依赖关系。主要分析对之前结果的依赖性。")]),t._v(" "),a("p",[t._v("如果是 f(n) = Max(f(n-1),f(n-2)) 这种，我们需要从小到大计算，因为必须知道 n-1,n-2 后才能计算 n。")]),t._v(" "),a("h3",{attrs:{id:"动态规划解题思路总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划解题思路总结"}},[t._v("#")]),t._v(" 动态规划解题思路总结")]),t._v(" "),a("ol",[a("li",[t._v("确定状态")]),t._v(" "),a("li",[t._v("转移方程")]),t._v(" "),a("li",[t._v("初始条件与边界情况")]),t._v(" "),a("li",[t._v("计算顺序")]),t._v(" "),a("li",[t._v("优化时间空间复杂度")])]),t._v(" "),a("h2",{attrs:{id:"常见动态规划类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见动态规划类型"}},[t._v("#")]),t._v(" 常见动态规划类型")]),t._v(" "),a("p",[t._v("坐标型\n序列型\n划分型\n区间型\n背包型\n最长序列型\n博弈型\n综合型\n树型")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://leetcode-cn.com/problems/house-robber-iii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("337. 打家劫舍 III"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("动态规划时间空间优化\n打印动态规划路径")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://leetcode-cn.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣 "),a("OutboundLink")],1)])]),t._v(" "),a("blockquote",[a("p",[t._v("更多相关专栏内容汇总：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/104020339",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 核心知识-专栏文章目录汇总 "),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/xiaohulunb/article/details/103594468",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 并发编程-专栏文章目录汇总 "),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/xiaohulunb/article/details/103828570",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java JVM（JDK13）-专栏文章目录汇总 "),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/xiaohulunb/article/details/104368031",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构与算法-专栏文章目录汇总 "),a("OutboundLink")],1)])])]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/gourderwa.footer.jpeg"}})])])}),[],!1,null,null,null);r.default=_.exports}}]);