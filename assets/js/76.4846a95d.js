(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{288:function(t,e,a){"use strict";a.r(e);var s=a(12),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"工作区、版本库、暂存区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作区、版本库、暂存区"}},[t._v("#")]),t._v(" 工作区、版本库、暂存区")]),t._v(" "),a("h3",{attrs:{id:"工作区（working-directory）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作区（working-directory）"}},[t._v("#")]),t._v(" 工作区（Working Directory）")]),t._v(" "),a("p",[t._v("你在电脑里能看到的目录，比如我的 "),a("code",[t._v("/Users/li/general-example")]),t._v(" 文件夹就是一个工作区.")]),t._v(" "),a("div",{staticClass:"language-shell script extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("➜  general-example git:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("feature/spring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" ✗ ll -la\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("\n.git\n.gitignore\n.idea\nREADME.md\nspring.md\n")])])]),a("h3",{attrs:{id:"版本库（repository）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本库（repository）"}},[t._v("#")]),t._v(" 版本库（Repository）")]),t._v(" "),a("p",[t._v("工作区有一个隐藏目录"),a("code",[t._v(".git")]),t._v("，这个不算工作区，而是 Git 的版本库。")]),t._v(" "),a("div",{staticClass:"language-shell script extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("➜  general-example git:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("feature/spring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" ✗  ll -la .git\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("\nCOMMIT_EDITMSG\nFETCH_HEAD\nHEAD\nORIG_HEAD\nconfig\ndescription\nhooks\nindex\ninfo\nlogs\nobjects\nrefs\n")])])]),a("h3",{attrs:{id:"暂存区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暂存区"}},[t._v("#")]),t._v(" 暂存区")]),t._v(" "),a("p",[t._v("Git 的版本库 ("),a("code",[t._v(".git")]),t._v(" 目录) 里存了很多东西，我们把版本库中的 "),a("code",[t._v(".git/index")]),t._v(" 目录称为缓存区（也叫作索引）")]),t._v(" "),a("p",[t._v("为什么要设计暂存区？以下看起来比较束手无策的场景，只要理解暂存区，用好相应命令，都能轻易解决：")]),t._v(" "),a("ul",[a("li",[t._v("修改了 4 个文件，在不放弃任何修改的情况下，其中一个文件不想提交，如何操作？（没 add : git add 。已经 add: git reset --soft ）")]),t._v(" "),a("li",[t._v("修改到一半的文件，突然间不需要或者放弃修改了，怎么恢复未修改前文件？ (git checkout)")]),t._v(" "),a("li",[t._v("代码写一半，被打断去做其他功能开发，未完成代码保存？(git stash)")]),t._v(" "),a("li",[t._v("代码写一半，发现忘记切换分支了？(git stash & git checkout)")]),t._v(" "),a("li",[t._v("代码需要回滚了？（git reset）")]),t._v(" "),a("li",[t._v("等等")])]),t._v(" "),a("h2",{attrs:{id:"head"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#head"}},[t._v("#")]),t._v(" HEAD")]),t._v(" "),a("p",[t._v("我们进入版本库 "),a("code",[t._v(".git")]),t._v(" 目录，发现 HEAD 文件指向如下 "),a("code",[t._v("HEAD->refs/heads/feature/spring->c063b04d21c690c251fba9ba0f4b653be0b71597")])]),t._v(" "),a("div",{staticClass:"language-shell script extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$ll")]),t._v(" -la\nCOMMIT_EDITMSG\nFETCH_HEAD\nHEAD\nORIG_HEAD\nconfig\ndescription\nhooks\nindex\ninfo\nlogs\nobjects\nrefs\n\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$cat")]),t._v(" HEAD\nref: refs/heads/feature/spring\n\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$cat")]),t._v(" refs/heads/feature/spring\nc063b04d21c690c251fba9ba0f4b653be0b71597\n")])])]),a("p",[t._v("因为 "),a("code",[t._v("refs/heads/")]),t._v(" 文件夹存储的内容是当前项目所有分支的头指针，每个分支的头指针都指向该分支的最新提交。为了保证多分支指向同一提交 ID 下， HEAD 还能正确指向，所以通过"),a("code",[t._v("refs/heads/")]),t._v("分支头指针指向而不是指向指向提交 ID。")]),t._v(" "),a("h3",{attrs:{id:"detached-head（游离的-head-指针）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#detached-head（游离的-head-指针）"}},[t._v("#")]),t._v(" detached HEAD（游离的 HEAD 指针）")]),t._v(" "),a("p",[t._v("使用 "),a("code",[t._v("git checkout <commit id>")]),t._v(" 或者 "),a("code",[t._v("git checkout --detach")]),t._v(" 进入了 detached HEAD 状态。\n在这个状态下，如果创建了新提交，新提交不属于任何分支。相对应的，现存的所有分支也不会受 detached HEAD 状态提交的影响。")]),t._v(" "),a("blockquote",[a("p",[t._v("例如:排查问题的时候，checkout 到怀疑的 commit 点上去做些测试，detached HEAD 会保护你的现有分支不受影响，测试完了不想保存直接 checkout 到其他地方，可以放弃修改。想保存修改，可以创建一个 git checkout -b "),a("new-branch-name",[t._v(" 新分支保存。")])],1)]),t._v(" "),a("h3",{attrs:{id:"head-指针总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#head-指针总结"}},[t._v("#")]),t._v(" HEAD 指针总结")]),t._v(" "),a("p",[t._v("版本库 "),a("code",[t._v(".git")]),t._v(" 目录下一共会出现以下五种 HEAD 类型指针。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("HEAD\n指向当前正在操作的 commit。")])]),t._v(" "),a("li",[a("p",[t._v("ORIG_HEAD\n当使用一些在 Git 看来比较危险的操作去移动 HEAD 指针的时候，ORIG_HEAD 就会被创建出来，记录危险操作之前的 HEAD，方便 HEAD 的恢复，有点像修改前的备份。")])]),t._v(" "),a("li",[a("p",[t._v("FETCH_HEAD\n记录从远程仓库拉取的记录。")])]),t._v(" "),a("li",[a("p",[t._v("MERGE_HEAD\n当运行 git merge 时，MERGE_HEAD 记录你正在合并到你的分支中的提交。MERGE_HEAD 在合并的时候会出现，合并结束，就删除了这个文件。")])]),t._v(" "),a("li",[a("p",[t._v("CHERRY_PICK_HEAD\n记录您在运行运行 git cherry-pick 时要合并的提交。同上，这个文件只在 cherry-pick 期间存在。")])])]),t._v(" "),a("p",[t._v("我们要清楚的知道，在这么多 xxx_HEAD 中，HEAD 指向的永远都是当前提交。而且 Git 的很多命令,在不给参数的情况下，默认操作都是 HEAD 指针。例如最前面我说的 git show 和另外一个很强大的命令 git reflog。")])])}),[],!1,null,null,null);e.default=n.exports}}]);