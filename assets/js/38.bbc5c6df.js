(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{398:function(t,r,e){"use strict";e.r(r);var a=e(18),_=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("专栏原创出处："),e("a",{attrs:{href:"https://github.com/GourdErwa/review-notes",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源笔记文件 "),e("OutboundLink")],1),t._v(" ，"),e("a",{attrs:{href:"https://github.com/GourdErwa/leetcode",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源码 "),e("OutboundLink")],1),t._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#_1-特点"}},[t._v("1. 特点")])]),e("li",[e("a",{attrs:{href:"#状态的定义"}},[t._v("状态的定义")])]),e("li",[e("a",{attrs:{href:"#_2-动态规划解题思路"}},[t._v("2.动态规划解题思路")]),e("ul",[e("li",[e("a",{attrs:{href:"#确定状态"}},[t._v("确定状态")])]),e("li",[e("a",{attrs:{href:"#转移方程"}},[t._v("转移方程")])]),e("li",[e("a",{attrs:{href:"#初始条件和边界情况"}},[t._v("初始条件和边界情况")])]),e("li",[e("a",{attrs:{href:"#计算顺序"}},[t._v("计算顺序")])]),e("li",[e("a",{attrs:{href:"#动态规划解题思路总结"}},[t._v("动态规划解题思路总结")])])])]),e("li",[e("a",{attrs:{href:"#常见动态规划类型"}},[t._v("常见动态规划类型")])]),e("li",[e("a",{attrs:{href:"#参考"}},[t._v("参考")])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"_1-特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-特点"}},[t._v("#")]),t._v(" 1. 特点")]),t._v(" "),e("p",[t._v("分值算法：将原问题划分为互不相交的子问题，递归地求解子问题，然后再将他们的解组合起来。")]),t._v(" "),e("p",[t._v("动态规划：子问题重叠的情况，不同的子问题具有公共的子子问题。")]),t._v(" "),e("p",[t._v("最优子结构：问题的最优解由相关子问题的最优解组合而成。")]),t._v(" "),e("p",[t._v("边界：问题的边界，得到有限的结果。")]),t._v(" "),e("p",[t._v("动态转移方程：问题每一阶段和下一阶段的关系")]),t._v(" "),e("h2",{attrs:{id:"状态的定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态的定义"}},[t._v("#")]),t._v(" 状态的定义")]),t._v(" "),e("ol",[e("li",[t._v("问题中的状态满足最优性原理。-》最优子结构")]),t._v(" "),e("li",[t._v("问题中的状态必须满足无后效性。-》以前出现的状态以及以前状态的变化不会影响将来的变化。")]),t._v(" "),e("li",[t._v("计数\n"),e("ul",[e("li",[t._v("有多少种方式走到右下角")]),t._v(" "),e("li",[t._v("有多少种方法选出 k 个数使得和是 Sum")])])]),t._v(" "),e("li",[t._v("最值\n"),e("ul",[e("li",[t._v("从左上角走到右下角路径的最大数字和")]),t._v(" "),e("li",[t._v("最长升子序列长度")])])]),t._v(" "),e("li",[t._v("存在性\n"),e("ul",[e("li",[t._v("取石子游戏，先手是否必胜")]),t._v(" "),e("li",[t._v("能不能选出k个数使得和是Sum")])])])]),t._v(" "),e("h2",{attrs:{id:"_2-动态规划解题思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态规划解题思路"}},[t._v("#")]),t._v(" 2.动态规划解题思路")]),t._v(" "),e("h3",{attrs:{id:"确定状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#确定状态"}},[t._v("#")]),t._v(" 确定状态")]),t._v(" "),e("ul",[e("li",[t._v("确定最优策略的最后一步")]),t._v(" "),e("li",[t._v("转换为子问题")])]),t._v(" "),e("h3",{attrs:{id:"转移方程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转移方程"}},[t._v("#")]),t._v(" 转移方程")]),t._v(" "),e("p",[t._v("根据子问题的定义写出递归方程")]),t._v(" "),e("h3",{attrs:{id:"初始条件和边界情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始条件和边界情况"}},[t._v("#")]),t._v(" 初始条件和边界情况")]),t._v(" "),e("h3",{attrs:{id:"计算顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算顺序"}},[t._v("#")]),t._v(" 计算顺序")]),t._v(" "),e("p",[t._v("需要看转移方程等式左边的变量与等式右边变量的依赖关系。主要分析对之前结果的依赖性。")]),t._v(" "),e("p",[t._v("如果是 f(n) = Max(f(n-1),f(n-2)) 这种，我们需要从小到大计算，因为必须知道 n-1,n-2 后才能计算 n。")]),t._v(" "),e("h3",{attrs:{id:"动态规划解题思路总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态规划解题思路总结"}},[t._v("#")]),t._v(" 动态规划解题思路总结")]),t._v(" "),e("ol",[e("li",[t._v("确定状态")]),t._v(" "),e("li",[t._v("转移方程")]),t._v(" "),e("li",[t._v("初始条件与边界情况")]),t._v(" "),e("li",[t._v("计算顺序")]),t._v(" "),e("li",[t._v("优化时间空间复杂度")])]),t._v(" "),e("h2",{attrs:{id:"常见动态规划类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见动态规划类型"}},[t._v("#")]),t._v(" 常见动态规划类型")]),t._v(" "),e("p",[t._v("坐标型\n序列型\n划分型\n区间型\n背包型\n最长序列型\n博弈型\n综合型\n树型")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/house-robber-iii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("337. 打家劫舍 III"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("动态规划时间空间优化\n打印动态规划路径")]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode-cn.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣 "),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.usejournal.com/top-50-dynamic-programming-practice-problems-4208fed71aa3",target:"_blank",rel:"noopener noreferrer"}},[t._v("50 个动态编程实践问题"),e("OutboundLink")],1)])]),t._v(" "),e("blockquote",[e("p",[t._v("更多相关专栏内容汇总：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/104020339",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 核心知识-专栏文章目录汇总 "),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/xiaohulunb/article/details/103594468",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 并发编程-专栏文章目录汇总 "),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/xiaohulunb/article/details/103828570",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java JVM（JDK13）-专栏文章目录汇总 "),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/xiaohulunb/article/details/104368031",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构与算法-专栏文章目录汇总 "),e("OutboundLink")],1)])])]),t._v(" "),e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/gourderwa.footer.jpeg"}})])])}),[],!1,null,null,null);r.default=_.exports}}]);