(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{284:function(e,t,r){"use strict";r.r(t);var a=r(0),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"executor-框架是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#executor-框架是什么"}},[e._v("#")]),e._v(" Executor 框架是什么")]),e._v(" "),r("p",[e._v("Java 线程的创建与销毁需要一定的开销，因此为每一个任务创建一个新线程来执行，线程的创建与开销将浪费大量计算资源。而且，如果不对创建线程的数量做限制，可能会导致系统负荷太高而崩溃。Java 的线程既是工作单元，也是执行机制。JDK1.5 之后，工作单元与执行机制分离，工作单元包括 Runnable 和 Callable，执行机制由 Executor 框架负责。")]),e._v(" "),r("h2",{attrs:{id:"executor-框架的两级调度模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#executor-框架的两级调度模型"}},[e._v("#")]),e._v(" Executor 框架的两级调度模型")]),e._v(" "),r("p",[e._v("在 HotSpot VM 的线程模型中，Java 线程被一对一映射为本地操作系统线程。Java 线程启动时会创建一个本地操作系统线程;当该 Java 线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的 CPU。")]),e._v(" "),r("ul",[r("li",[e._v("在上层，Java 多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器 (Executor 框架) 将这些任务映射为固定数量的线程;")]),e._v(" "),r("li",[e._v("在底层，操作系统内核将这些线程映射到硬件处理器上。")])]),e._v(" "),r("h2",{attrs:{id:"executor-框架组成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#executor-框架组成"}},[e._v("#")]),e._v(" Executor 框架组成")]),e._v(" "),r("p",[e._v("Executor 框架主要由 3 大部分组成如下：")]),e._v(" "),r("ol",[r("li",[e._v("任务的提交：包括被执行任务需要实现的接口:Runnable 接口或 Callable 接口。")]),e._v(" "),r("li",[e._v("任务的执行：包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 ExecutorService 接口。Executor 框架有两个关键类实现了 ExecutorService 接口 (ThreadPoolExecutor 和 ScheduledThreadPoolExecutor)。")]),e._v(" "),r("li",[e._v("任务的结果：异步计算的结果，包括接口 Future 和实现 Future 接口的 FutureTask 类。")])]),e._v(" "),r("h3",{attrs:{id:"任务的执行核心类说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#任务的执行核心类说明"}},[e._v("#")]),e._v(" 任务的执行核心类说明")]),e._v(" "),r("p",[e._v("任务的执行，核心接口 Executor 一些基础类继承关系图：\n")]),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/类图关系-Executor.png"}})]),r("p"),e._v(" "),r("h3",{attrs:{id:"任务提交与结果返回核心类说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#任务提交与结果返回核心类说明"}},[e._v("#")]),e._v(" 任务提交与结果返回核心类说明")]),e._v(" "),r("p",[e._v("任务的提交"),r("code",[e._v("Runnable 接口或 Callable 接口")]),e._v("与任务的结果 "),r("code",[e._v("Future 接口")]),e._v("关系图：\n")]),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/类图关系-Future.png"}}),e._v(" "),r("p",[e._v(" 类图关系-Future ")])]),r("p"),e._v(" "),r("p",[e._v("下面是这些类和接口的简介：")]),e._v(" "),r("ul",[r("li",[e._v("Executor 是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开。")]),e._v(" "),r("li",[e._v("ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。 ·ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大。")]),e._v(" "),r("li",[e._v("Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果。")]),e._v(" "),r("li",[e._v("Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。")])]),e._v(" "),r("h2",{attrs:{id:"threadpoolexecutor详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#threadpoolexecutor详解"}},[e._v("#")]),e._v(" ThreadPoolExecutor详解")]),e._v(" "),r("h2",{attrs:{id:"scheduledthreadpoolexecutor详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#scheduledthreadpoolexecutor详解"}},[e._v("#")]),e._v(" ScheduledThreadPoolExecutor详解")]),e._v(" "),r("h2",{attrs:{id:"futuretask详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#futuretask详解"}},[e._v("#")]),e._v(" FutureTask详解")])])}),[],!1,null,null,null);t.default=o.exports}}]);