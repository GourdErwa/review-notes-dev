(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{265:function(e,r,a){"use strict";a.r(r);var t=a(0),n=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("专栏原创出处："),a("a",{attrs:{href:"https://github.com/GourdErwa/review-notes/tree/master/language/java-concurrency",target:"_blank",rel:"noopener noreferrer"}},[e._v("github-源笔记文件 "),a("OutboundLink")],1),e._v(" ，"),a("a",{attrs:{href:"https://github.com/GourdErwa/java-advanced/tree/master/java-concurrency",target:"_blank",rel:"noopener noreferrer"}},[e._v("github-源码 "),a("OutboundLink")],1),e._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),e._v(" "),a("p",[e._v("Java 并发编程专栏系列笔记，系统性学习可访问个人技术博客 "),a("a",{attrs:{href:"https://review-notes.top/language/java-concurrency/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 并发编程"),a("OutboundLink")],1)]),e._v(" "),a("h4",{attrs:{id:"java-并发编程-基础篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-并发编程-基础篇"}},[e._v("#")]),e._v(" Java 并发编程-基础篇")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103408907",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 内存模型-基础概念 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103409054",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 内存模型-顺序一致性 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590975",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 并发编程-CAS 实现原理 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590976",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 内存模型-原子操作 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103438367",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 内存模型- final 域的内存语义 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590981",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 并发关键字-volatile"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590985",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 并发关键字-synchronized"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590987",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁的内存语义 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590989",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 并发操作比较（CAS、volatile、synchronized、Lock）"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103655219",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 原子操作类（atomic包）"),a("OutboundLink")],1)])]),e._v(" "),a("h4",{attrs:{id:"java-并发编程-线程篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-并发编程-线程篇"}},[e._v("#")]),e._v(" Java 并发编程-线程篇")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103619448",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 线程简介 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103619528",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 线程等待通知机制（wait、notify）"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103701793",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 线程等待操作比较（sleep、wait、park、Condition）"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103636811",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 线程关键类-ThreadLocal"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103636830",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 线程池简介 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103653384",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 线程池-Executor 框架 "),a("OutboundLink")],1)])]),e._v(" "),a("h4",{attrs:{id:"java-并发编程-锁篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-并发编程-锁篇"}},[e._v("#")]),e._v(" Java 并发编程-锁篇")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103670992",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁-Lock接口简介"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103671031",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁-AbstractQueuedSynchronizer介绍"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103685083",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁-AbstractQueuedSynchronizer原理"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103685111",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁-重入锁（ReentrantLock）"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103688286",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁-读写锁（ReentrantReadWriteLock）"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Java 锁-读写锁（StampedLock）（未完成）")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103698199",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁相关工具类（LockSupport）"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103701747",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁等待通知机制（Condition）"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590991",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁-死锁问题及解决方案 "),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://gourderwa.blog.csdn.net/article/details/103590994",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 锁类型总结 "),a("OutboundLink")],1)])]),e._v(" "),a("h4",{attrs:{id:"java-并发编程-容器和工具篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-并发编程-容器和工具篇"}},[e._v("#")]),e._v(" Java 并发编程-容器和工具篇")]),e._v(" "),a("ul",[a("li",[e._v("Java 并发容器-ConcurrentHashMap（未完成）")]),e._v(" "),a("li",[e._v("Java 并发容器-ConcurrentLinkedQueue（未完成）")]),e._v(" "),a("li",[e._v("Java 并发容器-阻塞队列（未完成）")]),e._v(" "),a("li",[e._v("Java 并行任务框架-Fork-Join（未完成）")]),e._v(" "),a("li",[e._v("Java 等待多线程完成-CountDownLatch（未完成）")]),e._v(" "),a("li",[e._v("Java 同步屏障-CyclicBarrier（未完成）")]),e._v(" "),a("li",[e._v("Java 控制并发数的信号量-Semaphore（未完成）")]),e._v(" "),a("li",[e._v("Java 线程交换数据-Exchanger（未完成）")])]),e._v(" "),a("p",[e._v("Java 并发编程专栏系列笔记，系统性学习可访问个人复盘笔记-技术博客 "),a("a",{attrs:{href:"https://review-notes.top/language/java-concurrency/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 并发编程"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=n.exports}}]);