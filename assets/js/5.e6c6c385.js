(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{219:function(t,r,e){t.exports=e.p+"assets/img/内存池继承体系.2ca5aeb4.png"},220:function(t,r,e){t.exports=e.p+"assets/img/ON_HEAP内存划分.3e2904b8.png"},311:function(t,r,e){"use strict";e.r(r);var a=e(0),o=Object(a.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("专栏原创出处："),a("a",{attrs:{href:"https://github.com/GourdErwa/review-notes/tree/master/framework/spark-basis",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源笔记文件 "),a("OutboundLink")],1),t._v(" ，"),a("a",{attrs:{href:"https://github.com/GourdErwa/spark-advanced",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源码 "),a("OutboundLink")],1),t._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#spark-内存的划分"}},[t._v("Spark 内存的划分")]),a("ul",[a("li",[a("a",{attrs:{href:"#on-heap-内存划分"}},[t._v("ON_HEAP 内存划分")])]),a("li",[a("a",{attrs:{href:"#off-heap-简介"}},[t._v("OFF_HEAP 简介")])])])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"spark-内存的划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spark-内存的划分"}},[t._v("#")]),t._v(" Spark 内存的划分")]),t._v(" "),a("p",[t._v("Spark 的内存除了用作计算资源之外，还将内存的一部分用作存储资源，Spark 使用 MemoryManager 对内存进行统一的管理。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Spark 在 MemoryMode 定义了两种内存类型，堆内存和堆外内存：ON_HEAP 和 OFF_HEAP。")])]),t._v(" "),a("li",[a("p",[t._v("Spark 定义了一个抽象类 MemoryPool 对内存进行管理，它需要一个保证线程安全的锁对象 lock，还有一个成员属性就是内存池的大小 _poolSize。该抽象类还定义了一些方法：获取内存池的大小、获取已用内存的大小、获取空余内存的大小、为内存池扩展指定 delta 大小的空间(delta 必须为正整数)、将内存池缩小指定大小 delta 的空间(delta 必须为正整数，且缩小后的空间大小要大于已经使用的空间大小)。")])]),t._v(" "),a("li",[a("p",[t._v("MemoryPool 有两个实现类，一个为存储体系服务，另一个为计算引擎服务。")])])]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{attrs:{src:e(219)}}),t._v(" "),a("p",[t._v("内存池继承体系")])]),t._v(" "),a("h3",{attrs:{id:"on-heap-内存划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#on-heap-内存划分"}},[t._v("#")]),t._v(" ON_HEAP 内存划分")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("首先预留出一部分系统空间 RESERVED_SYSTEM_MEMORY_BYTES，该内存大小默认为 300M。")])]),t._v(" "),a("li",[a("p",[t._v("剩余的也就是可用内存，可用内存默认的 60% 被用做统一内存，也就是 Storage 和 Execution，剩余的 40% 用来存储用户定义的一些数据或者 Spark 内部的元数据。二者的比例由 spark.memory.fraction 来控制，默认是 0.6。")])]),t._v(" "),a("li",[a("p",[t._v("统一内存默认被一分为二，一半用来缓存数据，也就是 StorageMemory，另一半为计算提供支持，用来缓存 Shuffle 过程产生的中间数据，也就是 ExecutionMemory。二者的比例由 spark.memory.storageFraction 来控制，默认是0.5。")])]),t._v(" "),a("li",[a("p",[t._v("StorageMemory 和 ExecutionMemory 存在动态占用的机制，任何一方资源不足时都可以占用另一方空余的资源。")])]),t._v(" "),a("li",[a("p",[t._v("当 Storage 占用了 Execution 的资源后，如果 Execution 需要更多的计算资源，会将 Storage 所占用的资源强行回收；相反，如果 Execution 占用了 Storage 的资源后，Storage 需要更多的存储资源时，无法强行回收 Execution 占用的资源。")])])]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{attrs:{src:e(220)}}),t._v(" "),a("p",[t._v("ON_HEAP内存划分")])]),t._v(" "),a("h3",{attrs:{id:"off-heap-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#off-heap-简介"}},[t._v("#")]),t._v(" OFF_HEAP 简介")]),t._v(" "),a("p",[t._v("Spark 中 RDD 提供了多种存储级别，除去使用内存，磁盘等，还有一种是 OFF_HEAP，又称为 JVM 堆外内存。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("OFF_HEAP 的优势在于，在内存有限时，可以减少频繁 GC 及不必要的内存消耗，提升程序性能。")])]),t._v(" "),a("li",[a("p",[t._v("OFF_HEAP 的缺点是没有数据备份，也不能保证数据高可用，丢失数据则需要重新计算。")])])])])}),[],!1,null,null,null);r.default=o.exports}}]);