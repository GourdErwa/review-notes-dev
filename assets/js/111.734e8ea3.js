(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{318:function(a,t,e){"use strict";e.r(t);var r=e(0),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("blockquote",[e("p",[a._v("专栏原创出处："),e("a",{attrs:{href:"https://github.com/GourdErwa/review-notes/tree/master/language/java-core",target:"_blank",rel:"noopener noreferrer"}},[a._v("github-源笔记文件 "),e("OutboundLink")],1),a._v(" ，"),e("a",{attrs:{href:"https://github.com/GourdErwa/java-advanced/tree/master/java-core",target:"_blank",rel:"noopener noreferrer"}},[a._v("github-源码 "),e("OutboundLink")],1),a._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),a._v(" "),e("p",[a._v("Java 核心知识专栏系列笔记，系统性学习可访问个人复盘笔记-技术博客 "),e("a",{attrs:{href:"https://review-notes.top/language/java-core/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java 核心知识 "),e("OutboundLink")],1)]),a._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#hashmap"}},[a._v("HashMap")])]),e("li",[e("a",{attrs:{href:"#hashmap-关键字段讲解"}},[a._v("HashMap 关键字段讲解")])]),e("li",[e("a",{attrs:{href:"#问"}},[a._v("问")])])])]),e("p"),a._v(" "),e("p",[a._v("基于 jdk1.8 讲解分析。")]),a._v(" "),e("h2",{attrs:{id:"hashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),e("h2",{attrs:{id:"hashmap-关键字段讲解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-关键字段讲解"}},[a._v("#")]),a._v(" HashMap 关键字段讲解")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("table"),e("br"),a._v(" "),e("code",[a._v("Node[]")]),a._v(" 结构的数组，保存我们的 K/V 键值对信息。Node 可能为单链表（Node）或者红黑树（TreeNode）结构，TreeNode 继承了 Node。")])]),a._v(" "),e("li",[e("p",[a._v("capacity"),e("br"),a._v("\n容量，即 table 的长度，默认 16")])]),a._v(" "),e("li",[e("p",[a._v("loadFactor"),e("br"),a._v("\n负载因子，默认 0.75f。决定了桶的使用情况。\n如果负载因子太大，桶的利用率越高，但是冲突的几率变大了。反之负载因子太小，桶的利用率越低，冲突几率变小了。平衡与折衷的默认值设置为 0.75f。\n可参考 "),e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111",target:"_blank",rel:"noopener noreferrer"}},[a._v("泊松分布和指数分布 "),e("OutboundLink")],1),a._v("。")])]),a._v(" "),e("li",[e("p",[a._v("threshold"),e("br"),a._v("\n扩容阈值，当 K/V 的数量大于等于该阈值时 table 进行扩容，初始化时默认为 16，进行 put 或者扩容操作后按公式"),e("code",[a._v("threshold = capacity * loadFactor")]),a._v("计算。\n假如我们的初始化容量是16，负载因子是0.75f。第一次扩容的阈值为12")])]),a._v(" "),e("li",[e("p",[a._v("size"),e("br"),a._v("\nK/V 的数量，即我们通过 put 方法放入 table 中的键值对。")])])]),a._v(" "),e("h2",{attrs:{id:"问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问"}},[a._v("#")]),a._v(" 问")]),a._v(" "),e("h4",{attrs:{id:"为什么-table-要设计为-node-结构的数组？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-table-要设计为-node-结构的数组？"}},[a._v("#")]),a._v(" 为什么 table 要设计为 "),e("code",[a._v("Node[]")]),a._v(" 结构的数组？")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("我们存入的 K/V 信息如何确定要保存到哪个数组下标呢？"),e("br"),a._v("\n通过 K 的哈希值定位到数组下标。")])]),a._v(" "),e("li",[e("p",[a._v("那如果多个 K 生成的哈希值出现都一样时（哈希冲突）怎么办？"),e("br"),a._v(" "),e("em",[a._v("此处应该是理解 HashMap 数据结构的重点了")]),a._v("。出现冲突后定位的数组索引下标都一样了，因此我们要在一个数组下标上放好多数据，\nHashMap 采用了 Node（单链表），TreeNode（红黑树）来保存每个数组下标的数据。")])]),a._v(" "),e("li",[e("p",[a._v("为什么要用 单链表、红黑树 两种树结构呢？")]),a._v(" "),e("ul",[e("li",[a._v("红黑树需要进行左旋，右旋操作， 而单链表不需要，单链表只能顺序查找。")]),a._v(" "),e("li",[a._v("如果元素小于 8 个，单链表，查询成本高，新增成本低")]),a._v(" "),e("li",[a._v("如果元素大于 8 个，红黑树，查询成本低，新增成本高")])])])]),a._v(" "),e("h4",{attrs:{id:"什么时候单链表与红黑树互相转换？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么时候单链表与红黑树互相转换？"}},[a._v("#")]),a._v(" 什么时候单链表与红黑树互相转换？")]),a._v(" "),e("ul",[e("li",[a._v("如果当前链表的个数 ≥ 8，且 capacity ≥ 64，单链表会转为红黑树。")]),a._v(" "),e("li",[a._v("如果当前红黑树的个数 ≤ 6，红黑树会转为单链表。")])]),a._v(" "),e("h4",{attrs:{id:"为什么容量为-2-次幂的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么容量为-2-次幂的原因"}},[a._v("#")]),a._v(" 为什么容量为 2 次幂的原因")])])}),[],!1,null,null,null);t.default=v.exports}}]);