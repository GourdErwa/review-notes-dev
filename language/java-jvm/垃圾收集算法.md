> 专栏原创出处：[github-源笔记文件 ](https://github.com/GourdErwa/review-notes/tree/master/language/java-jvm) ，[github-源码 ](https://github.com/GourdErwa/java-advanced/tree/master/java-jvm)，欢迎 Star，转载请附上原文出处链接和本声明。

Java JVM-虚拟机专栏系列笔记，系统性学习可访问个人复盘笔记-技术博客 [Java JVM-虚拟机 ](https://review-notes.top/language/java-jvm/)

[[toc]]
## 前言
本节内容主要说明为什么收集器要分代，以及常见的垃圾回收算法。

## 分代收集
收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

#### 为什么要分代？
1. 绝大多数对象都是朝生夕灭的。（新生代）

2. 熬过越多次垃圾收集过程的对象就越难以消亡。（老年代）

3. 跨代引用相对于同代引用来说仅占极少数。（跨代引用）

#### 不同分代使用不同的算法
针对上面分代的三点经验法则，在 Java 堆划分出不同的区域（新生代、老年代）。
- 垃圾收集器可以每次只回收其中某一个或者某些部分的区域。

- 针对不同的区域安排不同的的垃圾收集算法（标记-复制算法、标记-清除算法、标记-整理算法）。

#### 收集类型
- 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：
    - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。

    - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。

    - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。

- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。

> 请注意「Major GC」这个说法现在有点混淆，需按上下文区分到底是指老年代的收集还是整堆收集。
## 收集算法
### 标记-清除算法
- 「标记」首先标记出所有需要回收的对象，也可以反过来，标记存活的对象。标记过程就是对象是否属于垃圾的判定过程。
- 「清理」清理回收

主要缺点：
- 第一个是执行效率不稳定，如果 Java 堆中包含大量对象，其中大部分是需要被回收的，这时必须进行大量标记和清除的动作；
- 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，内存碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 标记-复制算法
- 「内存切分」它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
- 「复制-清理」当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

主要优点：
- 分配内存时也就不用考虑有空间碎片的复杂情况

主要缺点：
- 算法将会产生大量的内存间复制的开销
- 可用内存缩小为了原来的一半

> 老年代对象存活率高，一般不会采用此算法

### 标记-整理算法
- 「标记」首先标记出所有需要回收的对象，也可以反过来，标记存活的对象。标记过程就是对象是否属于垃圾的判定过程。
- 「整理」让存活的对象都向内存空间一端移动（将存活的与要死亡对象的分开）
- 「清理」清理边界以外的内存

主要优点：
- 分配内存时也就不用考虑有空间碎片的复杂情况

主要缺点：
- 移动存活对象需要更新引用「Stop World」

关于移动对象的影响：
- 从延迟时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿。
- 从整个程序的吞吐量来看，移动对象会更划算。

### 收集算法示意图

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-jvm/_images/垃圾收集算法.png">
</div>

## 总结
- 因为程序对象大多数时候朝生夕灭、少数情况越活越久、活的时间长的对活的时间短的依赖较少我们可以分代管理他们

- 针对不同的分代对象，我们可以使用不同的特征算法来收集

- 标记-清除算法，找出要死亡的对象清理掉（直接死）

- 标记-复制算法，一块内存划成 2 份，每次把活的移到一边后清理死亡的（活的去新地方后才能死）

- 标记-整理算法，找出存活的对象，移动到一边，和死亡的划清界限后清理死亡的（挪个地方，抱团一起死）

> 算法记忆的建议（d/c/s）：
>- 标记-清除，find-delete
>- 标记-复制，find-copy
>- 标记-整理，find-sort

## 参考
- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 3 版）》周志明 著