<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>复盘笔记预发布环境（不可作为正式学习环境）</title>
    <meta name="description" content="review notes">
    
    
    <link rel="preload" href="/assets/css/0.styles.0e76d28b.css" as="style"><link rel="preload" href="/assets/js/app.a0318ecf.js" as="script"><link rel="preload" href="/assets/js/2.38d84126.js" as="script"><link rel="preload" href="/assets/js/52.e76b01f8.js" as="script"><link rel="prefetch" href="/assets/js/10.c1137cb4.js"><link rel="prefetch" href="/assets/js/11.d34cecd9.js"><link rel="prefetch" href="/assets/js/12.4b6e7525.js"><link rel="prefetch" href="/assets/js/13.ade480c6.js"><link rel="prefetch" href="/assets/js/14.b9d116a7.js"><link rel="prefetch" href="/assets/js/15.3ec2dda9.js"><link rel="prefetch" href="/assets/js/16.f8cb1880.js"><link rel="prefetch" href="/assets/js/17.68d9ad40.js"><link rel="prefetch" href="/assets/js/18.2c43402d.js"><link rel="prefetch" href="/assets/js/19.1e7f952c.js"><link rel="prefetch" href="/assets/js/20.97155f2a.js"><link rel="prefetch" href="/assets/js/21.6ea3c59b.js"><link rel="prefetch" href="/assets/js/22.7a930e32.js"><link rel="prefetch" href="/assets/js/23.9cbcc2cb.js"><link rel="prefetch" href="/assets/js/24.ba0a53cb.js"><link rel="prefetch" href="/assets/js/25.2312ca49.js"><link rel="prefetch" href="/assets/js/26.2b16a806.js"><link rel="prefetch" href="/assets/js/27.51c72958.js"><link rel="prefetch" href="/assets/js/28.15fb8e87.js"><link rel="prefetch" href="/assets/js/29.086f7c49.js"><link rel="prefetch" href="/assets/js/3.2f62c258.js"><link rel="prefetch" href="/assets/js/30.45109945.js"><link rel="prefetch" href="/assets/js/31.dd10570c.js"><link rel="prefetch" href="/assets/js/32.b8afe4cc.js"><link rel="prefetch" href="/assets/js/33.55748cb6.js"><link rel="prefetch" href="/assets/js/34.bd3fb3c8.js"><link rel="prefetch" href="/assets/js/35.13df7c7d.js"><link rel="prefetch" href="/assets/js/36.23e8c351.js"><link rel="prefetch" href="/assets/js/37.115f354b.js"><link rel="prefetch" href="/assets/js/38.27a88271.js"><link rel="prefetch" href="/assets/js/39.67af1d1b.js"><link rel="prefetch" href="/assets/js/4.4828874e.js"><link rel="prefetch" href="/assets/js/40.5f9c5ed2.js"><link rel="prefetch" href="/assets/js/41.113bbb76.js"><link rel="prefetch" href="/assets/js/42.9b7a5c83.js"><link rel="prefetch" href="/assets/js/43.4e19327f.js"><link rel="prefetch" href="/assets/js/44.df44c0fc.js"><link rel="prefetch" href="/assets/js/45.0648fbba.js"><link rel="prefetch" href="/assets/js/46.d1eaeb2f.js"><link rel="prefetch" href="/assets/js/47.155c476a.js"><link rel="prefetch" href="/assets/js/48.a78bee87.js"><link rel="prefetch" href="/assets/js/49.08f2ca92.js"><link rel="prefetch" href="/assets/js/5.2b1ed303.js"><link rel="prefetch" href="/assets/js/50.a922be0f.js"><link rel="prefetch" href="/assets/js/51.7ae4f5bb.js"><link rel="prefetch" href="/assets/js/53.4851debf.js"><link rel="prefetch" href="/assets/js/54.15e0ddb9.js"><link rel="prefetch" href="/assets/js/55.2bd5a457.js"><link rel="prefetch" href="/assets/js/56.33dc2b4a.js"><link rel="prefetch" href="/assets/js/57.0c768697.js"><link rel="prefetch" href="/assets/js/58.21349b08.js"><link rel="prefetch" href="/assets/js/59.e4ec5b0d.js"><link rel="prefetch" href="/assets/js/6.adc0989b.js"><link rel="prefetch" href="/assets/js/60.f374d4aa.js"><link rel="prefetch" href="/assets/js/61.d8f8c91e.js"><link rel="prefetch" href="/assets/js/62.5329b47c.js"><link rel="prefetch" href="/assets/js/63.bb09d7df.js"><link rel="prefetch" href="/assets/js/64.20e2ada5.js"><link rel="prefetch" href="/assets/js/65.914c6743.js"><link rel="prefetch" href="/assets/js/66.417bd1cd.js"><link rel="prefetch" href="/assets/js/67.fc84c952.js"><link rel="prefetch" href="/assets/js/68.a06e27f1.js"><link rel="prefetch" href="/assets/js/69.44d999bd.js"><link rel="prefetch" href="/assets/js/7.cff821cb.js"><link rel="prefetch" href="/assets/js/70.70badb9d.js"><link rel="prefetch" href="/assets/js/71.c6942248.js"><link rel="prefetch" href="/assets/js/72.95815a2d.js"><link rel="prefetch" href="/assets/js/73.d5e52b55.js"><link rel="prefetch" href="/assets/js/8.e48f640e.js"><link rel="prefetch" href="/assets/js/9.3a080581.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0e76d28b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">复盘笔记预发布环境（不可作为正式学习环境）</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/java-concurrency/" class="nav-link router-link-active">Java 并发编程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术框架" class="dropdown-title"><span class="title">技术框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/flink-basis/" class="nav-link">Flink 入门进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/data-structures/" class="nav-link">数据结构</a></li></ul></div></div> <a href="https://github.com/GourdErwa/review-notes-dev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/java-concurrency/" class="nav-link router-link-active">Java 并发编程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术框架" class="dropdown-title"><span class="title">技术框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/flink-basis/" class="nav-link">Flink 入门进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/data-structures/" class="nav-link">数据结构</a></li></ul></div></div> <a href="https://github.com/GourdErwa/review-notes-dev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>并发编程-基础概念</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/language/java-concurrency/内存模型-基础概念.html" class="sidebar-link">内存模型-基础概念</a></li><li><a href="/language/java-concurrency/内存模型-顺序一致性.html" class="sidebar-link">内存模型-顺序一致性</a></li><li><a href="/language/java-concurrency/并发编程-CAS实现原理.html" class="sidebar-link">CAS实现原理</a></li><li><a href="/language/java-concurrency/内存模型-原子操作.html" class="sidebar-link">原子操作</a></li><li><a href="/language/java-concurrency/内存模型-final域的内存语义.html" class="sidebar-link">final域的内存语义</a></li><li><a href="/language/java-concurrency/并发关键字-volatile.html" class="sidebar-link">并发关键字-volatile</a></li><li><a href="/language/java-concurrency/并发关键字-synchronized.html" class="active sidebar-link">并发关键字-synchronized</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#synchronized-实现原理" class="sidebar-link">synchronized 实现原理</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#synchronized-的并发特性" class="sidebar-link">synchronized 的并发特性</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#如何使用" class="sidebar-link">如何使用</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#java-对象头" class="sidebar-link">Java 对象头</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#锁的升级与对比" class="sidebar-link">锁的升级与对比</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#应用场景" class="sidebar-link">应用场景</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#缺陷" class="sidebar-link">缺陷</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#注意事项" class="sidebar-link">注意事项</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/language/java-concurrency/并发关键字-synchronized.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/language/java-concurrency/锁的内存语义.html" class="sidebar-link">锁的内存语义</a></li><li><a href="/language/java-concurrency/锁类型总结.html" class="sidebar-link">锁类型总结</a></li><li><a href="/language/java-concurrency/锁-死锁问题.html" class="sidebar-link">死锁问题</a></li><li><a href="/language/java-concurrency/并发同步、锁定机制比较.html" class="sidebar-link">并发同步、锁定机制比较</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发编程-关键类分析</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>专栏原创出处：<a href="https://github.com/GourdErwa/review-notes/tree/master/language/java-concurrency" target="_blank" rel="noopener noreferrer">源笔记文件 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，<a href="https://github.com/GourdErwa/java-advanced/tree/master/java-concurrency" target="_blank" rel="noopener noreferrer">源码 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，转载请附上原文出处链接和本声明。</p></blockquote> <p></p><div class="table-of-contents"><ul><li><a href="#synchronized-实现原理">synchronized 实现原理</a></li><li><a href="#synchronized-的并发特性">synchronized 的并发特性</a></li><li><a href="#如何使用">如何使用</a></li><li><a href="#java-对象头">Java 对象头</a></li><li><a href="#锁的升级与对比">锁的升级与对比</a><ul><li><a href="#无锁">无锁</a></li><li><a href="#偏向锁">偏向锁</a></li><li><a href="#轻量级锁">轻量级锁</a></li><li><a href="#重量级锁">重量级锁</a></li><li><a href="#综述">综述</a></li><li><a href="#优缺点对比">优缺点对比</a></li></ul></li><li><a href="#应用场景">应用场景</a></li><li><a href="#缺陷">缺陷</a></li><li><a href="#注意事项">注意事项</a></li><li><a href="#总结">总结</a></li><li><a href="#参考">参考</a></li></ul></div><p></p> <h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="header-anchor">#</a> synchronized 实现原理</h2> <p>JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不一样。</p> <ul><li>代码块同步：使用 monitorenter 和 monitorexit 指令实现的</li> <li>方法同步：使用另外一种方式实现的，细节在 JVM 规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</li></ul> <hr> <ul><li>monitorenter 指令是在编译后插入到同步代码块的开始位置</li> <li>monitorexit 是插入到方法结束处和异常处</li></ul> <p>JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。<br>
任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p> <blockquote><p>synchronized 是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</p></blockquote> <h2 id="synchronized-的并发特性"><a href="#synchronized-的并发特性" class="header-anchor">#</a> synchronized 的并发特性</h2> <ul><li>synchronized 保证原子性
<ol><li>通过 monitorenter 和 monitorexit 指令，可以保证被 synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。</li> <li>即使在执行过程中，由于某种原因，比如 CPU 时间片用完，线程 1 放弃了 CPU，但是它并没有进行解锁。而由于 synchronized 的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。</li></ol></li> <li>synchronized 保证可见性：对一个 synchronized 修饰的变量解锁之前，必须先把此变量同步回主存中。</li> <li>synchronized 保证有序性：由于 synchronized 修饰的代码，同一时间只能被同一线程访问。（如果在本线程内观察，所有操作都是天然有序的），synchronized 是无法禁止指令重排和处理器优化的，但是同一线程内的执行遵守 as-if-serial 语义。</li> <li>可重入性：获得一次锁之后，如果调用其它同步方法，不需要重新获取锁，可以直接使用。</li> <li>不可中断性：一旦这个锁被某线程获得，其他线程只能等待或者阻塞。Lock 锁可以中断或者退出等待（超时机制）。</li></ul> <h2 id="如何使用"><a href="#如何使用" class="header-anchor">#</a> 如何使用</h2> <p>synchronized 实现同步的基础:Java 中的每一个对象都可以作为锁。具体表现为以下 3 种形式：</p> <ul><li>对于普通同步方法，锁是当前实例化的对象。</li> <li>对于静态同步方法，锁是当前类的 Class 对象。</li> <li>对于同步方法块，锁是 synchronized 括号里配置的对象。
<ul><li>synchronized(this) 表示锁是当前类实例对象，与同步方法块互斥</li> <li>synchronized(实例化对象引用) 表示锁是当前类实例对象，与同步方法块互斥</li> <li>synchronized(Object.class) 表示锁是类对象,与静态同步方法互斥</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> staticValue <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token comment">// 对于同步方法块，锁是 synchronized 括号里配置的对象-实例化对象</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 对于同步方法块，锁是 synchronized 括号里配置的对象-当前类对象</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SynchronizedExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 对于普通同步方法，锁是当前实例对象。</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 对于静态同步方法，锁是当前类的 Class 对象。</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> staticValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="java-对象头"><a href="#java-对象头" class="header-anchor">#</a> Java 对象头</h2> <blockquote><p>推荐工具-<a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener noreferrer">分析 JVM 中的对象布局方案的微型工具箱 openjdk-jol <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>synchronized 用的锁是存在 Java 对象头里的。（1 字宽 等于 4 字节，即 32bit）</p> <ul><li>如果对象是数组类型，则虚拟机用 3 个字宽 (Word) 存储对象头</li> <li>如果对象是非数组类型，则用 2 字宽存储对象头。在 32 位虚拟机中</li></ul> <div align="center"><img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/Java-对象头的长度.png"> <p>Java-对象头的长度</p></div> <hr> <p>Java 对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄和锁标记位。<br></p><div align="center"><img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/Java-对象头的存储结构.png"> <p>32 位 JVM 的 Mark Word 的默认存储结构</p></div><p></p> <hr> <p>在运行期间，Mark Word 里存储的数据会随着锁标志位的变化而变化。<br></p><div align="center"><img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/MarkWord-的状态变化.png"> <p>MarkWord-的状态变化</p></div><p></p> <hr> <p>在 64 位虚拟机下，Mark Word 是 64bit 大小的。<br></p><div align="center"><img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/MarkWord-的存储结构.png"> <p>偏向锁的初始化流程</p></div><p></p> <h2 id="锁的升级与对比"><a href="#锁的升级与对比" class="header-anchor">#</a> 锁的升级与对比</h2> <p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是:<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p> <h3 id="无锁"><a href="#无锁" class="header-anchor">#</a> 无锁</h3> <p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。<br></p> <p><strong>1.无锁的特点</strong>：就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p> <p><strong>2.实现机制</strong>：CAS 原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p> <h3 id="偏向锁"><a href="#偏向锁" class="header-anchor">#</a> 偏向锁</h3> <p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
 </p> <p><strong>1.为什么引入</strong>：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。
 </p> <p><strong>2.实现机制</strong>：当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。</p> <p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p> <p><strong>3.偏向锁的撤销</strong>：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p> <p><strong>4.关闭偏向锁</strong>：偏向锁在 JDK 6 及以后的 JVM 里是默认启用的。可以通过 JVM 参数<em>关闭偏向锁</em>：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p> <div align="center"><img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/偏向锁的初始化流程.png" height="720px"> <p>偏向锁的初始化流程</p></div> <h3 id="轻量级锁"><a href="#轻量级锁" class="header-anchor">#</a> 轻量级锁</h3> <p>轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p> <p><strong>加锁</strong>：在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。
拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。</p> <p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p> <p><strong>解锁</strong>：如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p> <p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p> <div align="center"><img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/language/java-concurrency/_images/轻量级锁及膨胀流程.png" height="720px"> <p>轻量级锁及膨胀流程</p></div> <h3 id="重量级锁"><a href="#重量级锁" class="header-anchor">#</a> 重量级锁</h3> <p>升级为重量级锁时，锁标志的状态值变为“10”，此时 Mark Word 中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p> <h3 id="综述"><a href="#综述" class="header-anchor">#</a> 综述</h3> <p>整体的锁状态升级流程如下：</p> <p>综上，偏向锁通过对比 Mark Word 解决加锁问题，避免执行 CAS 操作。而轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p> <h3 id="优缺点对比"><a href="#优缺点对比" class="header-anchor">#</a> 优缺点对比</h3> <table><thead><tr><th>锁</th> <th>优点</th> <th>缺点</th> <th>适用场景</th></tr></thead> <tbody><tr><td>偏向锁</td> <td>加锁和解锁不需要额外的消耗，和执行非同步方法相比存在纳秒级的差距</td> <td>如果多线程存在锁竞争会带来额外的锁撤销消耗</td> <td>适用于只有一个线程访问同步块</td></tr> <tr><td>轻量级锁</td> <td>竞争的线程不会阻塞，提高程序的响应速度</td> <td>一直得不到锁竞争的线程会自旋消耗CPU</td> <td>追求响应时间  同步块执行速度非常快</td></tr> <tr><td>重量级锁</td> <td>线程竞争不适应自旋，不会消耗CPU</td> <td>线程阻塞，响应时间缓慢</td> <td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table> <h2 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h2> <ul><li>并发访问同一非静态方法或非静态方法块</li> <li>并发访问同一静态方法或静态方法块</li></ul> <h2 id="缺陷"><a href="#缺陷" class="header-anchor">#</a> 缺陷</h2> <ul><li>效率低：锁的释放情况少，试图获得锁时不可设定超时、不可中断一个试图获取锁的线程</li> <li>不够灵活：加锁和解锁仅有一个单一的条件（对象或者类）</li> <li>无法感知是否成功获取到锁</li></ul> <h2 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h2> <ul><li>锁对象不能为空</li> <li>作用域不宜过大</li> <li>避免死锁</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>巩固提问：</p> <ul><li>synchronized 的实现原理及应用场景</li> <li>synchronized 在 Java SE 1.6 中减少获得锁和释放锁带来的性能消耗引入的偏向锁、轻量级锁实现机制</li></ul> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li>并发编程的艺术</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后修改时间:</span> <span class="time">12/16/2019, 3:09:57 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/language/java-concurrency/并发关键字-volatile.html" class="prev">并发关键字-volatile</a></span> <span class="next"><a href="/language/java-concurrency/锁的内存语义.html">锁的内存语义</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.a0318ecf.js" defer></script><script src="/assets/js/2.38d84126.js" defer></script><script src="/assets/js/52.e76b01f8.js" defer></script>
  </body>
</html>
