> 专栏原创出处：[github-源笔记文件 ](https://github.com/GourdErwa/review-notes/tree/master/algorithm/computer-theory) ，[github-源码 ](https://github.com/GourdErwa/java-advanced/tree/master/java-computer-theory)，欢迎 Star，转载请附上原文出处链接和本声明。

计算机理论专栏系列笔记，系统性学习可访问个人复盘笔记-技术博客 [计算机理论 ](https://review-notes.top/algorithm/computer-theory)

[[toc]]

## 前提概念
### 机器数
一个数在计算机中的二进制表示形式，叫做这个数的机器数。  
机器数是带符号的，在计算机用机器数的最高位存放符号，正数为 0，负数为 1。
> 用一个 4 位的二进制表示，最高位是符号位，0001 换成十进制为 1 ，1001 换成十进制为 -1。本篇文章使用 4 位的二进制进行描述。

### 机器数的真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。

例如：二进制 $1001$ ，高位的 1 是符号位，后面的 001 是真值。
- 以二进制数换算成十进制是 $2^3 + 2^0 = 9$
- 以机器数的真值去换算成十进制是 $2^0 = -1$

### 为什么计算机没有减法？
对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单，计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂。

于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：$1 - 1 = 1 + (-1) = 0$， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

### 补数的概念
我们的钟表，现在时针指向 3 点，如果想指向到 2 点怎么办，可以倒拨 1 也可以正拨 11，我们可以认为是-1 与 11 互为补数。同理 -2 与 10 互为补数。  
那么 12 就是模，符号记作（mod 12），求一个数的补数可以记为：
- -3 互补 9(mod 12)
- -4 互补 8(mod 12)
- -5 互补 7(mod 12)

> 以上截取自《计算机组成原理·第二版》唐朔飞著 p221

所以我们减去一个数的时候，在计算机里可以用加它的补数来实现，这样减法就变成了加法。

其实补数就是补码的概念，只是叫法不同。台湾和香港“一的补数/一补数”表示大陆的“反码”，“二的补数/二补数”才表示大陆的“补码”。

## 原码
原码就是符号位加上机器数的真值。

## 反码
反码是用来表示负数的，在原码基础上，符号位不变，其余位置取反。
- 正数的反码，为本身
- 负数的反码，为符号不变其余求反

反码通常是用来由原码求补码或者由补码求原码的过渡码。
> 此处不需要太纠结它。因为反码并不能解决减法的运算问题，但是计算机可能会使用反码进行存储用于其他计算，如有求知欲可深入研究。

## 补码
补码是用来处理负数的，负数的补码就是它的补数。

上面钟表示例中的 -3 的补码就是 9 。

补码与原码快速转换公式（并不是补码的定义）：
- 在反码的基础上，加 1。
- 至低位向高位，第一个 "1" 和 1 后面的 "0" 不变，符号位不变，其余位置取反。

#### 当运算结果为负数时，计算结果怎么表示？
结果不为 0 的运算同样可以通过使用补码来得到正确的结果。  
如果结果为负数，也是通过补码的形式来表示的。

比如：$3-5=-2$，即 $0011 + 1011 = 1110$ ，1110 的最高位为 1，表示是一个负数。  
我们可以通过"负负为正"来计算他是多少，对它取反后加 1 为 1010。
$010=2^1=2$ ，因此结果为 -2

## 总结

