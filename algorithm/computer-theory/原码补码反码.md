> 专栏原创出处：[github-源笔记文件 ](https://github.com/GourdErwa/review-notes/tree/master/algorithm/computer-theory) ，[github-源码 ](https://github.com/GourdErwa/java-advanced/tree/master/java-computer-theory)，欢迎 Star，转载请附上原文出处链接和本声明。

计算机理论专栏系列笔记，系统性学习可访问个人复盘笔记-技术博客 [计算机理论 ](https://review-notes.top/algorithm/computer-theory)

[[toc]]

## 前提概念
### 机器数
一个数在计算机中的二进制表示形式，叫做这个数的机器数。  
机器数是带符号的，在计算机用机器数的最高位存放符号，正数为 0，负数为 1。
> 用一个 4 位的二进制表示，最高位是符号位，0001 换成十进制为 1 ，1001 换成十进制为 -1。本篇文章使用 4 位的二进制进行描述。

### 机器数的真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。

例如：二进制 $1001$ ，高位的 1 是符号位，后面的 001 是真值。
- 以二进制数换算成十进制是 $2^3 + 2^0 = 9$
- 以机器数的真值去换算成十进制是 $2^0 = -1$

### 为什么计算机没有减法？
对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单，计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂。

于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：$1 - 1 = 1 + (-1) = 0$， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

## 原码
原码就是符号位加上机器数的真值。

#### 问题一：减法运算结果错误
我们做一个减法运算 ：$1 - 1 = 0$  
换算成二进制加法运算 ：$0001 + 1001 = 1010(-2)$。发现居然结果是错误的。
#### 问题二：2 个 0
- 0000 表示 +0
- 1000 表示 -0

居然有 2 种 0 的表示方法，而且 0 带符号是没有任何意义的。

## 反码
反码表示方式是用来处理负数的，符号位置不变，其余位置相反。

计算机做减法运算时实际上在做加法运算，为此在表示负数时就需要使用"二进制的反码"。

#### 解决问题一
我们把 -1(原码 1001) 求反码后为 1110，我们重新运算：$0001 + 1110 = 1111(-0)$

问题一居然解决了，那么为什么把 -1 求反码后再运算就结果正确了呢？  
因为，原码 + 反码 = 0 。例如 $1-1=0 , 39-39=0$ 可以改为加法运算 $1+(-1)=0 , 39+(-39)=0$

> 形象的举例：加法换算成减法的等式为 A - 原码 = A + 反码  
> 只要 "- 原码 = 反码" 等式就成立，因为"原码 + 反码 = 0" 所以最终等式成立

那么为什么"原码 + 反码 = 0" 呢 ？  
因为反码是在原码除符号位其他位置取反，然后在和原码相加时，两两相加和都是 0，最终溢出一位，结果就是 0。

比如：1110（原码） + 1001（原码对应的反码） = 1111（反码），反码 1111 对应的原码即 -0。

***

但是 2 个 0 的问题依旧没有解决，为了解决这个问题出现了 *补码* 的概念。

## 补码
反码表示方式是用来处理负数的，在反码的基础上，加 1。

补码的意思就是一个数的补数，类似于十进制，12 相对于 100 的补数是 88。二进制里面，1 相对 1 的补数时 1。
#### 解决问题一
针对问题一：我们把 -1(原码 1001) 求补码后为 1111，我们重新运算：$0001 + 1111 = 0000(+0)$

#### 解决问题二
因为补码等于反码加 1，那么 $-0(1111)$ 永远不会存在了，因为 $-0(1111)+1(0001) = 0(0000)$(溢出位丢弃)

#### 当运算结果为负数时，计算结果怎么表示？
结果不为 0 的运算同样可以通过使用补码来得到正确的结果。  
如果结果为负数，也是通过补码的形式来表示的。

比如：$3-5=-2$，即 $0011 + 1011 = 1110$ ，1110 的最高位为 1，表示是一个负数。  
我们可以通过"负负为正"来计算他是多少，对它取反后加 1 为 1010。
$010=2^1=2$ ，因此结果为 -2

#### 为什么要做加 1 操作？
因为如果不 +1，可能出现 1111（-0）这种数据。为了去掉一个（-0），取反后 +1。1111（-0）+1 后变为 0000（+0）。

可以发现设计时，只保留了一个 0（+0）。

同样，失去（-0），4 位机器数最小的负数可以表示到 -8（反码 1001，原码 1111）

***

那么 +1 后最终结果应该也 +1 了吧？  
结果不是，因为拿到一个反码（负数）时我们再次求反码来计算他的真值。即负负的正的过程。

比如：01 -> `取反为 10 -> +1 为 11` -> `取反为 00 -> +1 为 01`。最终还是一样的。

## 总结
- 因为计算机的减法运算变成加法运算，提出了反码来表示负数
- 因为反码在计算过程会出现 2 个 0 ，提出了补码
- 因为补码会在反码基础上+1，因此，会舍弃 -0 ，但是会得到一个最小的负数，补码也是表示负数
- 对于结果为负数的补码，我们可以转换为原码查看
- 因为机器使用补码，所以对于编程中常用到的有符号的 32 位 int 类型，可以表示范围是: -2^$31$ - 2^$31$-1 ，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。

